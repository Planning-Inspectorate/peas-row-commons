generator client {
  provider = "prisma-client"
  output   = "./client"

  engineType = "client"
  runtime    = "nodejs"
}

datasource db {
  provider = "sqlserver"
}

// NOTES
//
// use '//' comments for notes relevant to the schema
// use '///' comments for notes that should be included in the types definition
// see https://www.prisma.io/docs/concepts/components/prisma-schema#comments
//
// we use GUIDs for IDs (see https://learn.microsoft.com/en-us/sql/t-sql/data-types/uniqueidentifier-transact-sql?view=sql-server-ver16)
// this is because these IDs may be used in URLs and it makes them harder to guess
// while we don't rely on that for security, it adds an extra layer
// not everything needs this, but easier to make them all consistent and the increase in size (vs int) is negligible

/// Case represents a case in the system
model Case {
  /// internal identifier
  id                       String                        @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  createdDate              DateTime                      @default(now())
  updatedDate              DateTime?
  receivedDate             DateTime
  closedDate               DateTime?
  /// type of case
  typeId                   String
  Type                     CaseType                      @relation(fields: [typeId], references: [id])
  /// subtype of case
  subTypeId                String?
  SubType                  CaseSubType?                  @relation(fields: [subTypeId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  /// shown to users as a unique reference
  reference                String                        @unique
  /// external identifier, optional unlike reference above
  externalReference        String?
  /// historical reference, if existing case from Horizon
  historicalReference      String?
  name                     String
  siteAddressId            String?                       @db.UniqueIdentifier
  SiteAddress              Address?                      @relation(fields: [siteAddressId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  location                 String?
  caseOfficerId            String?                       @db.UniqueIdentifier
  CaseOfficer              User?                         @relation("caseOfficer", fields: [caseOfficerId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  linkedCases              String?
  Dates                    CaseDates?
  /// Physical location of real-world files
  filesLocation            String?
  Folders                  Folder[]
  Costs                    CaseCosts?
  Abeyance                 CaseAbeyance?
  Notes                    CaseNote[]
  Documents                Document[]
  DraftDocuments           DraftDocument[]
  statusId                 String?
  Status                   CaseStatus?                   @relation(fields: [statusId], references: [id])
  advertisedModificationId String?
  AdvertisedModification   AdvertisedModificationStatus? @relation(fields: [advertisedModificationId], references: [id])
  applicantId              String?                       @db.UniqueIdentifier
  Applicant                Applicant?                    @relation(fields: [applicantId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  authorityid              String?                       @db.UniqueIdentifier
  Authority                Authority?                    @relation(fields: [authorityid], references: [id], onUpdate: NoAction, onDelete: NoAction)
  priorityId               String?
  Priority                 CasePriority?                 @relation(fields: [priorityId], references: [id])
  /// The relevant legislation / act
  act                      String?
  /// What type of consent has been sought
  consentSought            String?
  /// The band for the inspector
  inspectorBandId          String?
  InspectorBand            InspectorBand?                @relation(fields: [inspectorBandId], references: [id])
  Decision                 CaseDecision?
  /// Legacy Case ID for migration, will be removed after
  legacyCaseId             String?
  Procedures               Procedure[]
  /// The primary procedure
  primaryProcedureStep     String?                       @db.NVarChar(50)
  /// Inspectors allocated to case
  Inspectors               Inspector[]
  /// Contacts linked to a case
  Contacts                 Contact[]
  /// Related Cases to this case
  RelatedCases             RelatedCase[]
  /// Cases linked to this case
  LinkedCases              LinkedCase[]
}

model User {
  id            String         @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Identity provider Id, currently using Entra Id
  idpUserId     String?        @unique
  /// Id from legacy system, in case no ipdUserId can be found in migration
  legacyId      String?
  CaseOfficer   Case[]         @relation("caseOfficer")
  Author        CaseNote[]     @relation("author")
  DecisionMaker CaseDecision[] @relation("decisionMaker")
  Inspector     Inspector[]    @relation("inspector")
}

model CaseworkArea {
  /// unique machine-readable name, not generated
  id          String     @id
  displayName String?
  caseTypes   CaseType[]
}

/// CaseType represents types of cases we receive
model CaseType {
  /// unique machine-readable name, not generated
  id             String        @id
  displayName    String?
  Case           Case[]
  SubTypes       CaseSubType[]
  caseworkAreaId String
  CaseworkArea   CaseworkArea  @relation(fields: [caseworkAreaId], references: [id], onDelete: NoAction)
}

/// CaseSubType represents subtypes of cases we receive
model CaseSubType {
  /// unique machine-readable name, not generated
  id           String   @id
  displayName  String?
  Case         Case[]
  parentTypeId String
  ParentType   CaseType @relation(fields: [parentTypeId], references: [id])
}

/// Address represents an address of a property or place
model Address {
  /// internal identifier
  id                  String      @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  line1               String?
  line2               String?
  townCity            String?
  county              String?
  postcode            String?
  Case                Case[]
  /// Legacy Case ID for migration, will be removed after
  legacyCaseId        String?
  ConferenceProcedure Procedure[] @relation("ProcedureConferenceVenue")
  HearingProcedure    Procedure[] @relation("ProcedureHearingVenue")
  InquiryProcedure    Procedure[] @relation("ProcedureInquiryVenue")
  Contact             Contact[]
}

/// Dates that are associated with a case, a couple more generic ones are
/// kept on the main Case table (e.g. createdDate)
model CaseDates {
  id                                      String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// The project start date.
  startDate                               DateTime?
  /// When it is expected that the case will be submitted
  expectedSubmissionDate                  DateTime?
  /// Date offer for consent ends
  consentDeadlineDate                     DateTime?
  /// Due date for Other Government Departments (OGD)
  ogdDueDate                              DateTime?
  /// Date proposal letter sent to e.g. Secretary of State
  proposalLetterDate                      DateTime?
  /// Date the case expires
  expiryDate                              DateTime?
  /// Date parties sent an event notification
  partiesDecisionNotificationDeadlineDate DateTime?
  /// Date for the target decision
  targetDecisionDate                      DateTime?
  /// Date when the case officer verified the case
  caseOfficerVerificationDate             DateTime?
  /// Date proposed modifications were advertised
  proposedModificationsDate               DateTime?
  /// Date the objection period ends
  objectionPeriodEndsDate                 DateTime?
  caseId                                  String    @unique @db.UniqueIdentifier
  Case                                    Case      @relation(fields: [caseId], references: [id])
}

/// Folder model
/// Contains folders created for each case that will contain documents.
model Folder {
  id             String          @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  displayName    String
  displayOrder   Int?
  parentFolderId String?         @db.UniqueIdentifier
  caseId         String?         @db.UniqueIdentifier
  isCustom       Boolean         @default(false)
  deletedAt      DateTime?
  Case           Case?           @relation(fields: [caseId], references: [id])
  ParentFolder   Folder?         @relation("FolderTree", fields: [parentFolderId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  ChildFolders   Folder[]        @relation("FolderTree")
  Documents      Document[]
  DraftDocuments DraftDocument[]

  @@unique([caseId, displayName, parentFolderId, deletedAt])
}

model CaseCosts {
  id           String           @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  rechargeable Boolean?
  finalCost    Decimal?
  feeReceived  Boolean?
  invoiceSent  String?
  InvoiceSent  CaseInvoiceSent? @relation(fields: [invoiceSent], references: [id])
  caseId       String           @unique @db.UniqueIdentifier
  Case         Case             @relation(fields: [caseId], references: [id])
}

model CaseInvoiceSent {
  /// unique machine-readable name, not generated, e.g. "interim"
  id          String      @id
  displayName String?
  CaseCosts   CaseCosts[]
}

model CaseAbeyance {
  id                String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  abeyanceStartDate DateTime?
  abeyanceEndDate   DateTime?
  withdrawalDate    DateTime?
  caseId            String    @unique @db.UniqueIdentifier
  Case              Case      @relation(fields: [caseId], references: [id])
}

model CaseNote {
  id           String   @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  comment      String
  createdAt    DateTime @default(now())
  authorId     String   @db.UniqueIdentifier
  Author       User     @relation("author", fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  caseId       String   @db.UniqueIdentifier
  Case         Case     @relation(fields: [caseId], references: [id])
  ///Legacy Horizon Case ID this note originated from used for migration
  legacyCaseId String?
  /// The type of this note (e.g. Case note, Sticky note, Important info)
  noteTypeId   String   @default("case-note")
  NoteType     NoteType @relation(fields: [noteTypeId], references: [id])
}

model NoteType {
  /// unique machine-readable name, not generated, e.g. "case-note"
  id          String     @id
  displayName String?
  CaseNotes   CaseNote[]
}

model CaseStatus {
  /// unique machine-readable name, not generated, e.g. "new-case"
  id          String  @id
  displayName String?
  Case        Case[]
}

model AdvertisedModificationStatus {
  /// unique machine-readable name, not generated, e.g. "advertised-modification-1"
  id          String  @id
  displayName String?
  Case        Case[]
}

model CasePriority {
  /// unique machine-readable name, not generated, e.g. "high"
  id          String  @id
  displayName String?
  Case        Case[]
}

model Document {
  id           String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  fileName     String
  uploadedDate DateTime  @default(now())
  size         BigInt    @default(0)
  blobName     String
  mimeType     String    @default("application/octet-stream")
  deletedAt    DateTime?
  caseId       String    @db.UniqueIdentifier
  Case         Case      @relation(fields: [caseId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  folderId     String    @db.UniqueIdentifier
  Folder       Folder    @relation(fields: [folderId], references: [id], onDelete: Cascade)
}

/// Indicates a document that has been uploaded
/// to blob but has not yet been committed as a 
/// real document in the DB.
model DraftDocument {
  id         String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  sessionKey String
  caseId     String @db.UniqueIdentifier
  Case       Case   @relation(fields: [caseId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  folderId   String @db.UniqueIdentifier
  Folder     Folder @relation(fields: [folderId], references: [id], onDelete: Cascade)
  fileName   String
  blobName   String
  size       BigInt
  mimeType   String @default("application/octet-stream")

  @@index([sessionKey, caseId])
}

model Applicant {
  id   String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  name String
  Case Case[]
}

model Authority {
  id   String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  name String
  Case Case[]
}

model InspectorBand {
  /// unique machine-readable name, not generated, e.g. "1"
  id          String  @id
  displayName String?
  Case        Case[]
}

model CaseDecision {
  id                           String        @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// Decision maker for the case
  decisionMakerId              String?       @db.UniqueIdentifier
  DecisionMaker                User?         @relation("decisionMaker", fields: [decisionMakerId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  /// The date the actual decision outcome was determinied
  outcomeDate                  DateTime?
  /// The date the decision was received 
  decisionReceivedDate         DateTime?
  /// Whether decision was received within the target timeframe
  inTarget                     Boolean?
  /// The date relevant parties (e.g. appellant) were notified of the decision.
  partiesNotifiedDate          DateTime?
  /// The date the decision regarding an order was dispatched
  orderDecisionDispatchDate    DateTime?
  /// The date the sealed order was returned
  sealedOrderReturnedDate      DateTime?
  /// The date the decision was published
  decisionPublishedDate        DateTime?
  /// Indicates if the fencing in question is deemed permanent
  isFencingPermanent           Boolean?
  /// Details explaining the permanent fencing decision
  fencingPermanentComment      String?       @db.NVarChar(2000)
  /// Details or specific conditions applied if the outcome is 'Granted with Conditions'
  grantedWithConditionsComment String?       @db.NVarChar(2000)
  /// Reasoning provided if the Inspector proposes NOT to confirm an order
  proposeNotToConfirmComment   String?       @db.NVarChar(2000)
  decisionTypeId               String?
  DecisionType                 DecisionType? @relation(fields: [decisionTypeId], references: [id])
  outcomeId                    String?
  Outcome                      Outcome?      @relation(fields: [outcomeId], references: [id])
  caseId                       String        @unique @db.UniqueIdentifier
  Case                         Case          @relation(fields: [caseId], references: [id])
}

model DecisionType {
  /// unique machine-readable name, not generated, e.g. "interim"
  id           String         @id
  displayName  String?
  CaseDecision CaseDecision[]
}

model Outcome {
  /// unique machine-readable name, not generated, e.g. "allow"
  id           String         @id
  displayName  String?
  CaseDecision CaseDecision[]
}

model Procedure {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// Core procedure data
  procedureTypeId             String?
  ProcedureType               ProcedureType?   @relation(fields: [procedureTypeId], references: [id])
  procedureStatusId           String?
  ProcedureStatus             ProcedureStatus? @relation(fields: [procedureStatusId], references: [id])
  caseOfficerVerificationDate DateTime?

  /// Date of site visit
  siteVisitDate DateTime?

  /// Site visit type
  siteVisitTypeId String?
  SiteVisitType   SiteVisitType? @relation(fields: [siteVisitTypeId], references: [id])

  /// Admin procedure type
  adminProcedureType String?
  AdminProcedureType AdminProcedureType? @relation(fields: [adminProcedureType], references: [id])

  /// Timeline of hearing
  hearingTargetDate    DateTime?
  earliestHearingDate  DateTime?
  confirmedHearingDate DateTime?
  hearingClosedDate    DateTime?

  /// Hearing notifications
  hearingDateNotificationDate  DateTime?
  hearingVenueNotificationDate DateTime?
  partiesNotifiedOfHearingDate DateTime?

  /// Hearing data
  lengthOfHearingEvent       Decimal?
  hearingInTarget            Boolean?
  hearingPreparationTimeDays Decimal?
  hearingTravelTimeDays      Decimal?
  hearingSittingTimeDays     Decimal?
  hearingReportingTimeDays   Decimal?

  /// Format & venue of hearings
  hearingFormatId String?
  HearingFormat   ProcedureEventFormat? @relation("HearingFormat", fields: [hearingFormatId], references: [id])
  hearingVenueId  String?               @db.UniqueIdentifier
  HearingVenue    Address?              @relation("ProcedureHearingVenue", fields: [hearingVenueId], references: [id], onUpdate: NoAction, onDelete: NoAction)

  /// Timeline of inquiry
  inquiryTargetDate    DateTime?
  earliestInquiryDate  DateTime?
  confirmedInquiryDate DateTime?
  inquiryFinishedDate  DateTime?
  inquiryClosedDate    DateTime?

  /// Inquiry notifications
  inquiryDateNotificationDate  DateTime?
  inquiryVenueNotificationDate DateTime?
  partiesNotifiedOfInquiryDate DateTime?

  /// Data around inquiry event, e.g. length, time
  lengthOfInquiryEvent       Decimal?
  inquiryInTarget            Boolean?
  inquiryPreparationTimeDays Decimal?
  inquiryTravelTimeDays      Decimal?
  inquirySittingTimeDays     Decimal?
  inquiryReportingTimeDays   Decimal?

  /// Format & venue of inquiry meetings
  inquiryFormatId String?
  InquiryFormat   ProcedureEventFormat? @relation("InquiryFormat", fields: [inquiryFormatId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  inquiryVenueId  String?               @db.UniqueIdentifier
  InquiryVenue    Address?              @relation("ProcedureInquiryVenue", fields: [inquiryVenueId], references: [id], onUpdate: NoAction, onDelete: NoAction)

  /// Dates for conference / pre inquiry meetings
  conferenceDate         DateTime?
  conferenceNoteSentDate DateTime?
  preInquiryMeetingDate  DateTime?
  preInquiryNoteSentDate DateTime?

  /// Format & venue of conference
  conferenceFormatId String?
  ConferenceFormat   ProcedureEventFormat? @relation("ConferenceFormat", fields: [conferenceFormatId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  conferenceVenueId  String?               @db.UniqueIdentifier
  ConferenceVenue    Address?              @relation("ProcedureConferenceVenue", fields: [conferenceVenueId], references: [id], onUpdate: NoAction, onDelete: NoAction)

  preInquiryMeetingFormatId String?
  PreInquiryMeetingFormat   ProcedureEventFormat? @relation("PreInquiryMeetingFormat", fields: [preInquiryMeetingFormatId], references: [id], onUpdate: NoAction, onDelete: NoAction)

  /// Whether it is an inquiry or conference
  inquiryOrConferenceId String?
  InquiryOrConference   InquiryOrConference? @relation(fields: [inquiryOrConferenceId], references: [id])

  /// Dates for submission of documents
  proofsOfEvidenceReceivedDate       DateTime?
  statementsOfCaseReceivedDate       DateTime?
  inHouseDate                        DateTime?
  offerForWrittenRepresentationsDate DateTime?

  caseId String @db.UniqueIdentifier
  Case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)

  /// Identifies what number this procedure is (e.g. 'ProcedureOne')
  step String @db.NVarChar(50)

  @@unique([caseId, step], name: "Unique_Procedure_Step_Per_Case")
}

/// Types for different events formats, e.g. 'virtual or hybrid'
model ProcedureEventFormat {
  /// unique machine-readable name, not generated
  id          String  @id
  displayName String?

  HearingProcedures    Procedure[] @relation("HearingFormat")
  InquiryProcedures    Procedure[] @relation("InquiryFormat")
  ConferenceProcedures Procedure[] @relation("ConferenceFormat")
  PreInquiryProcedures Procedure[] @relation("PreInquiryMeetingFormat")
}

model ProcedureType {
  /// unique machine-readable name, not generated, e.g. "written-reps"
  id          String      @id
  displayName String?
  Procedure   Procedure[]
}

model ProcedureStatus {
  /// unique machine-readable name, not generated, e.g. "Active"
  id          String      @id
  displayName String?
  Procedure   Procedure[]
}

model InquiryOrConference {
  /// unique machine-readable name, not generated, e.g. "pre-inquiry-meeting
  id          String      @id
  displayName String?
  Procedure   Procedure[]
}

model SiteVisitType {
  /// unique machine-readable name, not generated, e.g. "arsv"
  id          String      @id
  displayName String?
  Procedure   Procedure[]
}

model AdminProcedureType {
  /// unique machine-readable name, not generated, e.g. "case-officer"
  id          String      @id
  displayName String?
  Procedure   Procedure[]
}

model Inspector {
  id                     String   @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  inspectorId            String   @db.UniqueIdentifier
  Inspector              User     @relation("inspector", fields: [inspectorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  inspectorAllocatedDate DateTime
  caseId                 String   @db.UniqueIdentifier
  Case                   Case     @relation(fields: [caseId], references: [id])
}

model Contact {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// Generic columns
  orgName         String?
  firstName       String?
  lastName        String?
  telephoneNumber String?
  email           String?
  addressId       String?  @db.UniqueIdentifier
  Address         Address? @relation(fields: [addressId], references: [id])

  /// Objector specific colummns
  objectorStatusId String?
  ObjectorStatus   ObjectorStatus? @relation(fields: [objectorStatusId], references: [id])

  contactTypeId String?
  ContactType   ContactType? @relation(fields: [contactTypeId], references: [id])
  caseId        String       @db.UniqueIdentifier
  Case          Case         @relation(fields: [caseId], references: [id])
}

model ContactType {
  /// unique machine-readable name, not generated, e.g. "objector"
  id          String    @id
  displayName String?
  Contacts    Contact[]
}

model ObjectorStatus {
  /// unique machine-readable name, not generated, e.g. "admissable"
  id          String    @id
  displayName String?
  Contacts    Contact[]
}

model RelatedCase {
  id        String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  reference String?
  caseId    String  @db.UniqueIdentifier
  Case      Case    @relation(fields: [caseId], references: [id])
}

model LinkedCase {
  id        String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  reference String?
  isLead    Boolean @default(false)
  caseId    String  @db.UniqueIdentifier
  Case      Case    @relation(fields: [caseId], references: [id])
}
