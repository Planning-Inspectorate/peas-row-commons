generator client {
  provider = "prisma-client"
  output   = "./client"

  engineType = "client"
  runtime    = "nodejs"
}

datasource db {
  provider = "sqlserver"
}

// NOTES
//
// use '//' comments for notes relevant to the schema
// use '///' comments for notes that should be included in the types definition
// see https://www.prisma.io/docs/concepts/components/prisma-schema#comments
//
// we use GUIDs for IDs (see https://learn.microsoft.com/en-us/sql/t-sql/data-types/uniqueidentifier-transact-sql?view=sql-server-ver16)
// this is because these IDs may be used in URLs and it makes them harder to guess
// while we don't rely on that for security, it adds an extra layer
// not everything needs this, but easier to make them all consistent and the increase in size (vs int) is negligible

/// Case represents a case in the system
model Case {
  /// internal identifier
  id                       String                        @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  createdDate              DateTime                      @default(now())
  updatedDate              DateTime?
  receivedDate             DateTime
  closedDate               DateTime?
  /// type of case
  typeId                   String
  Type                     CaseType                      @relation(fields: [typeId], references: [id])
  /// subtype of case
  subTypeId                String?
  SubType                  CaseSubType?                  @relation(fields: [subTypeId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  /// shown to users as a unique reference
  reference                String                        @unique
  /// external identifier, optional unlike reference above
  externalReference        String?
  /// internal reference, if existing case from Horizon
  internalReference        String?
  name                     String
  siteAddressId            String?                       @db.UniqueIdentifier
  SiteAddress              Address?                      @relation(fields: [siteAddressId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  location                 String?
  /// Entra ID
  caseOfficerId            String
  procedureId              String?
  Procedure                CaseProcedure?                @relation(fields: [procedureId], references: [id])
  linkedCases              String?
  Dates                    CaseDates?
  /// Physical location of real-world files
  filesLocation            String?
  Folders                  Folder[]
  Costs                    CaseCosts?
  invoiceSentId            String?
  InvoiceSent              CaseInvoiceSent?              @relation(fields: [invoiceSentId], references: [id])
  Abeyance                 CaseAbeyance?
  Notes                    CaseNote[]
  Documents                Document[]
  statusId                 String?
  Status                   CaseStatus?                   @relation(fields: [statusId], references: [id])
  advertisedModificationId String?
  AdvertisedModification   AdvertisedModificationStatus? @relation(fields: [advertisedModificationId], references: [id])
  applicantId              String?                       @db.UniqueIdentifier
  Applicant                Applicant?                    @relation(fields: [applicantId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  authorityid              String?                       @db.UniqueIdentifier
  Authority                Authority?                    @relation(fields: [authorityid], references: [id], onUpdate: NoAction, onDelete: NoAction)
  priorityId               String?
  Priority                 CasePriority?                 @relation(fields: [priorityId], references: [id])
}

model CaseworkArea {
  /// unique machine-readable name, not generated
  id          String     @id
  displayName String?
  caseTypes   CaseType[]
}

/// CaseType represents types of cases we receive
model CaseType {
  /// unique machine-readable name, not generated
  id             String        @id
  displayName    String?
  Case           Case[]
  SubTypes       CaseSubType[]
  caseworkAreaId String
  CaseworkArea   CaseworkArea  @relation(fields: [caseworkAreaId], references: [id], onDelete: NoAction)
}

/// CaseSubType represents subtypes of cases we receive
model CaseSubType {
  /// unique machine-readable name, not generated
  id           String   @id
  displayName  String?
  Case         Case[]
  parentTypeId String
  ParentType   CaseType @relation(fields: [parentTypeId], references: [id])
}

/// CaseProcedure represents the procedure type a case will follow
model CaseProcedure {
  /// unique machine-readable name, not generated, e.g. "inquiry"
  id          String  @id
  displayName String?
  Case        Case[]
}

/// Address represents an address of a property or place
model Address {
  /// internal identifier
  id       String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  line1    String?
  line2    String?
  townCity String?
  county   String?
  postcode String?
  Case     Case[]
}

/// Dates that are associated with a case, a couple more generic ones are
/// kept on the main Case table (e.g. createdDate)
model CaseDates {
  id                                      String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  /// The project start date.
  startDate                               DateTime?
  /// The date that the objection period ends
  objectionPeriodEndsDate                 DateTime?
  /// When it is expected that the case will be submitted
  expectedSubmissionDate                  DateTime?
  /// Date feedback via written representation is submitted
  offerForWrittenRepresentationDate       DateTime?
  /// Date offer for consent ends
  consentDeadlineDate                     DateTime?
  /// A target date for an envement
  targetEventDate                         DateTime?
  /// Due date for Other Government Departments (OGD)
  ogdDueDate                              DateTime?
  /// Date proposal letter sent to e.g. Secretary of State
  proposalLetterDate                      DateTime?
  /// Date the case expires
  expiryDate                              DateTime?
  /// Date parties sent a deadline notification
  partiesEventNotificationDeadlineDate    DateTime?
  /// Date parties sent an event notification
  partiesDecisionNotificationDeadlineDate DateTime?
  caseId                                  String    @unique @db.UniqueIdentifier
  Case                                    Case      @relation(fields: [caseId], references: [id])
}

/// Folder model
/// Contains folders created for each case that will contain documents.
model Folder {
  id             String     @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  displayName    String
  displayOrder   Int?
  parentFolderId String?    @db.UniqueIdentifier
  caseId         String?    @db.UniqueIdentifier
  isCustom       Boolean    @default(false)
  deletedAt      DateTime?
  Case           Case?      @relation(fields: [caseId], references: [id])
  ParentFolder   Folder?    @relation("FolderTree", fields: [parentFolderId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  ChildFolders   Folder[]   @relation("FolderTree")
  Documents      Document[]

  @@unique([caseId, displayName, parentFolderId, deletedAt])
}

model CaseCosts {
  id           String   @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  rechargeable Boolean?
  finalCost    Decimal?
  feeReceived  Boolean?
  invoiceSent  String?
  caseId       String   @unique @db.UniqueIdentifier
  Case         Case     @relation(fields: [caseId], references: [id])
}

model CaseInvoiceSent {
  /// unique machine-readable name, not generated, e.g. "interim"
  id          String  @id
  displayName String?
  Case        Case[]
}

model CaseAbeyance {
  id                String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  abeyanceStartDate DateTime?
  abeyanceEndDate   DateTime?
  withdrawalDate    DateTime?
  caseId            String    @unique @db.UniqueIdentifier
  Case              Case      @relation(fields: [caseId], references: [id])
}

model CaseNote {
  id            String   @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  comment       String
  createdAt     DateTime @default(now())
  authorEntraId String
  caseId        String   @db.UniqueIdentifier
  Case          Case     @relation(fields: [caseId], references: [id])
}

model CaseStatus {
  /// unique machine-readable name, not generated, e.g. "new-case"
  id          String  @id
  displayName String?
  Case        Case[]
}

model AdvertisedModificationStatus {
  /// unique machine-readable name, not generated, e.g. "advertised-modification-1"
  id          String  @id
  displayName String?
  Case        Case[]
}

model CasePriority {
  /// unique machine-readable name, not generated, e.g. "high"
  id          String  @id
  displayName String?
  Case        Case[]
}

model Document {
  id           String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  fileName     String
  uploadedDate DateTime  @default(now())
  size         BigInt    @default(0)
  blobName     String
  mimeType     String
  deletedAt    DateTime?
  caseId       String    @db.UniqueIdentifier
  Case         Case      @relation(fields: [caseId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  folderId     String    @db.UniqueIdentifier
  Folder       Folder    @relation(fields: [folderId], references: [id], onDelete: Cascade)
}

/// Indicates a document that has been uploaded
/// to blob but has not yet been committed as a 
/// real document in the DB.
model DraftDocument {
  id         String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  sessionKey String
  /// Purposefully do not create real PK-FK relations for simplicity
  /// and speed, this is just a draft row.
  caseId     String
  folderId   String
  fileName   String
  blobName   String
  size       BigInt
  mimeType   String

  @@index([sessionKey, caseId])
}

model Applicant {
  id              String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  name            String
  email           String
  telephoneNumber String
  Case            Case[]
}

model Authority {
  id              String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  name            String
  email           String
  telephoneNumber String
  Case            Case[]
}
